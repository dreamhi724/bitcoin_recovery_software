""" This module recovers lost words from your Bitcoin phrase."""
""" need help? Or do you need us to adjust the code? You can contact us at: rphessing @ gmail com or www.rseindustries.com """ 

__version__ = '1'
__author__ = '''Ron Hessing & David O'Reilly'''

import hashlib # import build-in hashlib package
import hmac # import build-in hmac package

import sys # to see size of the magic list

''' Task 1: Open default 2048 word list'''
file = open('2048wordlist_EN.txt') # depending on language file can change
_2048wordlist = file.read().split('\n') # .split returns a list of words
file.close()

''' Task 2: User provides known and unknown word positions'''
incomplete_phrase_words = "x y work aisle faculty exist ketchup clerk z p mistake q"
#incomplete_phrase_words = "adult mule x aisle y exist ketchup clerk great coin z become"
incomplete_phrase_words = incomplete_phrase_words.split() # .split returns a list

''' Task 3: User provides b58 wallet historical transaction keys'''
# Provided by user from their wallet transaction history
user_bitcoin_addresses = ['1HhppX8g8TwRU6MUVGdhd6aFFWvFkuVHmq',
                          '1FREiBXQV1UP3FpDFRERML8ioVgRzQo6Zz',
                          '1Gfb8qiTwfwnodHtPD1RxQpQixmYb9QgoP',
                          '1vBUDfm42diz9bDxszc91azXR2js5Mpdz']  

''' Task 4: create new list to store index numbers of unknown words '''
unknown_word_positions = []

supersonic_magic_list = [] 

''' Task 5: User provides wallet name to extract the wallet settings entered below''' 
deriv_code = "m/0'/0" # user input
child_addresses_are_hardened = False # user input

''' Task 6: User defines search range depending on the wallet used, and Bitcoin addresses
entered in the user_bitcoin_addresses.'''
# By default, the first bitcoin address generated by a wallet, is address 0 or 
# child_index_start 0. Some wallets may start at child index number 100. Based upon the wallet
# used and the estimated location of the ‘user_bitcoin_addresses' please define the range.
child_index_start = 0 # user input
child_index_end = 20 # user input

''' Task 7: Validate ‘user_bitcoin_addresses’ input '''
# Old-style Bitcoin addresses are case-sensitive
# A Bitcoin address is between 26 and 34 characters long
# the address always starts with a 1 or 3 
# an address can contain all alphanumeric characters, except 0, O, I, and l.

# There are currently three Bitcoin address formats IN USE:
#  P2PKH (BIP 16) which begin with 1,      eg: 1BvBMSEYstWetqTFn5Au4m4GFg7xJaNVN2
#  P2SH (BIP 16) type starting with 3,     eg: 3J98t1WpEZ73CNmQviecrnyiWrnqRhWNLy
#  Bech32 (BIP 173) type starting with bc1 eg: bc1qar0srrr7xfkvy5l643lydnw9re59gtzzwf5mdq
# Bech32 (BIP 173) type NOT supported
def validate_user_bitcoin_addresses():
    for address in user_bitcoin_addresses:
        bitcoin_address_character_count = (len(address))
        
        if bitcoin_address_character_count < 26 or bitcoin_address_character_count > 34:
            print(f'''Invalid amount of characters found. Address: {address}. Length: 
            {bitcoin_address_character_count} characters. A Bitcoin address is between 25 
            and 34 characters long. Please review and try again.''')
            exit(0)
            
        elif '0' in address or 'O' in address or 'I' in address or 'l' in address:
            print('''Error: Invalid character found in address {address}. An address can 
            contain all alphanumeric characters, except 0, O, I, and l. Please review and 
            try again.''')
            exit(0)

        elif not ('1' in address[0] or '3' in address[0]):
            print(f"Error for address: {address}. Invalid currency. \
            Bitcoin currency supported only.") 
            print(address)
            exit(0)          
        else:
            pass

''' Task 8: Identify unknown word positions AND convert words to binary '''
def words_to_binary():
    # list to store each of the known phrase words into binary format
    incomplete_phrase_binary = [] 
    for word in incomplete_phrase_words: 
        if (word != 'x') and (word != 'y') and (word != 'z') and (word != 'p') and (word != 'q'): 
            word_nr = _2048wordlist.index(word) # variable = 2048 word list index number
            # converts word_nr to binary and fills up till 11 bits
            incomplete_phrase_binary.append(format(word_nr, 'b').zfill(11)) 
        elif word == 'x' or 'y' or 'z' or 'p' or 'q':
            # to track unkown words index numbers
            unknown_word_positions.append(incomplete_phrase_words.index(word)) 
            # if word is 'x' replace it with 'x' at end of list
            incomplete_phrase_binary.append(word) 
        else:
            print("word not found in list")
    return incomplete_phrase_binary
        
''' Task 11: Validates the checksum of the complete phrase in binary format'''
# if valid it can continue to proceed with the next task: Generate Seed
def validate_phrase(complete_phrase_binary_string, checksum_length):
    # separate entropy from the checksum
    entropy = complete_phrase_binary_string[:-checksum_length]
    # convert entropy binary to bytes # Possible double!!
    entropy_bytes = int(entropy, 2).to_bytes((len(entropy) + 7) // 8, byteorder='big') 
    # hash the entropy bytes
    hashed_entropy_bytes = hashlib.sha256(entropy_bytes).digest()
    # convert hashkey to binary
    hashed_entropy_binary = ''.join((format(item_in_list, 'b').zfill(8) for item_in_list 
    in hashed_entropy_bytes))
  
    # if checksum is equal to last 4 digits of complete phrase binary (if True), then
    # generate_seed. If False, then ‘pass’ and next ‘nested_loop’ starts.
    if hashed_entropy_binary [:checksum_length] == (complete_phrase_binary_string
    [-checksum_length:]):
        return True # 10% is True
    else:
        return False # If False, then ‘pass’ and next ‘nested_loop’ starts. 90% is false.

''' Task 12: Generate complete phrase words'''        
def generate_complete_phrase(complete_phrase_binary_string):
## convert unknown words from binary into integers, then into words using _2048wordlist 
    for position in unknown_word_positions:
        # if ‘position’ of missing word is ‘2’ for example, then 
        # take from characters 22 to 33 in complete_phrase_binary_string
        word_nr = int(complete_phrase_binary_string[position * 11 : (position + 1) * 11]
        , 2)
        missing_word = _2048wordlist[word_nr]
        incomplete_phrase_words[position] = missing_word
    complete_phrase_words = ' '.join(incomplete_phrase_words)
    #print('complete_phrase_words of valid Bitcoin seed:', complete_phrase_words)
    return complete_phrase_words
    
''' Task 13: Generate Bitcoin Seed, also called BOP39 Seed'''
def generate_seed(complete_phrase_words):      
# Hash the 12 word phrase 
# !! make sure hashlib.pbkdf2_hmac uses OpenSSL 1.1 or higher to double performance
    passphrase = '' # Some wallets include this option as part of hash
    seed_bytes = hashlib.pbkdf2_hmac('sha512', bytes(complete_phrase_words, 
    encoding='utf-8'), bytes('mnemonic' + passphrase, encoding='utf-8'), 2048)
    return seed_bytes
   
''' Task 14: Generate master private key (64 letters and numbers) ## keep it secret and 
safe in your pillow'''
def generate_master_private_key(seed_bytes):
    hashed_seed = hmac.new(bytes("Bitcoin seed", 'utf-8'), seed_bytes, 
    hashlib.sha512).hexdigest() # KEY FIRST = Bitcoin seed, String to sign SECOND = seed
    master_private_key_hex = hashed_seed[:len(hashed_seed)//2] # As IL in BIP32 Doc.
    master_chain_code_hex = hashed_seed[len(hashed_seed)//2:] # As IR in BIP32 Doc.
    
    return master_private_key_hex, master_chain_code_hex
    
''' Task 15: Generate lowest private parent from master private key and master chain code'''    
def find_lowest_private_parent_key(master_private_key_hex, master_chain_code_hex, deriv_code):
   parent_private_key_hex = master_private_key_hex
   parent_chain_code_hex = master_chain_code_hex
# error check for wrong user input missing
   #deriv_code = "m/0'/0" # parent (user input)
   deriv_code_list = deriv_code.split('/')
   for item in deriv_code_list[1:]:
        if item[-1] == "\'":
            hardened = True
            index = int(item[:-1])
            parent_private_key_hex, parent_chain_code_hex = (
            generate_private_child_key(parent_private_key_hex, 
            parent_chain_code_hex, index, hardened))
        else:
            hardened = False
            index = int(item)
            (parent_private_key_hex, parent_chain_code_hex) = (
            generate_private_child_key(parent_private_key_hex,
            parent_chain_code_hex, index, hardened))
            
   lowest_parent_private_key_hex, lowest_parent_chain_code_hex = (
   parent_private_key_hex, parent_chain_code_hex)

   return lowest_parent_private_key_hex, lowest_parent_chain_code_hex
      
''' Task 16: Generate child private key (from parent private key)'''
    # for both hardened and non-hardened keys
def generate_private_child_key(parent_private_key_hex, parent_chain_code_hex,
    child_index_int, hardened): 
    parent_private_key_bytes = bytes.fromhex(parent_private_key_hex)
    
    if hardened == True: # hardened key
        child_index_int = child_index_int + (2**31)
        index_bytes = child_index_int.to_bytes(4, byteorder='big')
        double_zero = bytes.fromhex('00')
        parent_private_key_bytes_modified = (double_zero + parent_private_key_bytes + 
        index_bytes)
        
    else: # non-hardened key
        index_bytes = child_index_int.to_bytes(4, byteorder='big')
        parent_private_key_bytes = generate_elliptic_curve(parent_private_key_hex)
        parent_private_key_bytes_modified = (parent_private_key_bytes + index_bytes)
    
    n = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141
    # N, a constant as mentioned in BIP32 doc. 
    # see also: http://www.secg.org/sec2-v2.pdf#subsubsection.2.4.1
    parent_chain_code_bytes = bytes.fromhex(parent_chain_code_hex)
    hashed_key_hex = hmac.new(parent_chain_code_bytes,
    parent_private_key_bytes_modified, hashlib.sha512).hexdigest() 
    hashed_key_left_hex = hashed_key_hex[:64] # hex string 64 not 32 because its hex
    child_chain_code_hex = hashed_key_hex[64:] # Not used
    hashed_key_left_int = int(hashed_key_left_hex, 16) # hex string into INT
    parent_private_key_int = int(parent_private_key_hex, 16)
    child_private_key_int = (hashed_key_left_int + parent_private_key_int) % n

    # 'invalid key' Error handling. Chance is lower than 1 in 2^127.  
    if child_private_key_int == 0 or child_private_key_int > n: raise Exception("\
    Invalid Private Key") # correct. n = 1
    
    child_private_key_hex = hex(child_private_key_int)
    # When ‘% n’ applies it generates 63 characters (instead of 64) and zfill req. 
    child_private_key_hex = (child_private_key_hex[2:]).zfill(64)

    return child_private_key_hex, child_chain_code_hex

''' Task 18: Generate public child adresses (bitcoin addresses)'''
# function that calls other functions below this function
def generate_public_child_addresses(lowest_parent_private_key_hex, 
    lowest_parent_chain_code_hex, child_index_int):
    
    # child private key generation       
    private_child_key, child_chain_code_hex = (
    generate_private_child_key(lowest_parent_private_key_hex, 
    lowest_parent_chain_code_hex, child_index_int, child_addresses_are_hardened))
    
    # public key calculated from elliptic_curve function
    public_key_bytes = generate_elliptic_curve(private_child_key)
    public_key_int = generate_p2pkh(public_key_bytes)
    base58_string = convert_int_to_b58(public_key_int)
    return base58_string

'''Task 19: Generate P2PKH format of compressed public key'''
def generate_p2pkh(public_key_bytes): 
    hashed_public_key_bytes = hashlib.sha256(public_key_bytes).digest() #hash public key
    ripemd160_hashed_public_key_bytes = hashlib.new('ripemd160', 
    hashed_public_key_bytes).digest() # second hash
    prefix_ripemd160_hashed_public_key_bytes = (b'\x00' + 
    ripemd160_hashed_public_key_bytes) # ad bitcoin prefix = 0x00
    hashed_prefix_ripemd160_hashed_public_key_bytes = hashlib.sha256(
    prefix_ripemd160_hashed_public_key_bytes).digest() # hash key (again)
    double_hashed_prefix_ripemd160_hashed_public_key_bytes = hashlib.sha256(
    hashed_prefix_ripemd160_hashed_public_key_bytes).digest() # hash key (again)
    checksum = double_hashed_prefix_ripemd160_hashed_public_key_bytes[:4] # get checksum
    prefix_ripemd160_hashed_public_key_bytes_with_checksum = (
    prefix_ripemd160_hashed_public_key_bytes + checksum) # add checksum to key
    
    # If public key starts with one zero (byte) (\x00) then here it counts 1 zero
    # We hardcode the zero (byte) prefix on prefix_ripemd160_hashed_public_key_bytes
    # so this function is required if this script support multiple cryptocurrencies
    #zero_bytes_counter = len(prefix_ripemd160_hashed_public_key_bytes_with_checksum
    #) - len(prefix_ripemd160_hashed_public_key_bytes_with_checksum.lstrip(b'\x00'))

    public_key_int = int.from_bytes(
    prefix_ripemd160_hashed_public_key_bytes_with_checksum, 'big') # convert to int
    return public_key_int

"""Task 20: Convert Public Key INT into B58"""     
def convert_int_to_b58(public_key_int):
    # 58 character alphabet used
    alphabet = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'
    base58_string = ''
    while public_key_int >= 1:
        modulus = int(public_key_int % 58)
        base58_string = alphabet[modulus] + base58_string
        public_key_int = public_key_int // 58

    # If public key starts with one zero (byte) (\x00) then here it counts 1 zero
    # We hardcode the zero (byte) prefix on prefix_ripemd160_hashed_public_key_bytes
    # so this for loop is required if this script support multiple cryptocurrencies
    #for item in range(zero_bytes_counter):
    #    base58_string = '1' + base58_string
    base58_string = '1' + base58_string # hardcoded. 
    return base58_string
    
""" Task 21: Compare generated ‘Public key' with provided ‘user public key’. """
# If match, 12 phrase word recovery was successful.
def address_search(base58_string):    
    address_match = False
    # print(base58_string)
    if base58_string in user_bitcoin_addresses:
        address_match = True
    else:
        pass
    return address_match
    
######################################################################################

''' Task A: Generate public key Bytes''' 
# a public key is 256 bits. 
# Step 2 of 2 to generate Bitcoin address. 
def generate_elliptic_curve(private_key_hex):
    # elliptic_curve function
    #secp256k1 domain parameters
    p_curve = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F
    #p_curve = 2**256 - 2**32 - 2**9 - 2**8 - 2**7 - 2**6 - 2**4 -1
    a_curve = 0; # These two define the elliptic curve. 
    # y^2 = x^3 + a_curve * x_axe + b_curve
    #b_curve = 7; # not used
    g_x = 0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798 
    g_y = 0x483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8
    g_spot = (int(g_x),int(g_y)) # This is our generator point.
    q = g_spot
    #print('private key hex:', private_key_hex)
    #print(type(private_key_hex))
    private_key_bin = str(bin(int(private_key_hex, 16)))[2:] # key in binary string
    # ECC Multiplier
    for i in range (1, len(private_key_bin)):
        lm, hm = 1, 0 
        low, high = (2 * q [1]) % p_curve, p_curve
        
        while low > 1:
            ratio = high // low
            nm, new = hm - lm * ratio, high - low * ratio
            lm, low, hm, high = nm, new, lm, low
    # EC Double
        lam = ((3 * q[0] * q[0] + a_curve) * (lm % p_curve)) % p_curve 
        x_axe = (lam * lam - 2 * q[0]) % p_curve
        y_axe = (lam * (q[0] - x_axe) - q[1]) % p_curve
        q = (x_axe,y_axe) # re-assign q
    # EC Add
        if private_key_bin [i] == '1':
            lm, hm = 1, 0
            low, high = (g_spot[0] - q[0]) % p_curve, p_curve
    
            while low > 1:
                ratio = high//low
                nm, new = hm - lm * ratio, high - low * ratio
                lm, low, hm, high = nm, new, lm, low
    
            lam_add = ((g_spot[1] - q[1]) * (lm % p_curve)) % p_curve
            x_axe = (lam_add * lam_add - q[0] - g_spot[0]) % p_curve
            y_axe = (lam_add * (q[0] - x_axe) - q[1]) % p_curve
            q = (x_axe,y_axe) # re-assign q
        else:
            pass
    # end of elliptic_curve 

    public_key_int = q[0] 

    # specify length for integers to bytes function
    public_key_bit_length = max(1, (public_key_int.bit_length() + 7) // 8)   
    # convert integers to bytes function
    public_key_bytes = public_key_int.to_bytes(public_key_bit_length, byteorder='big')

# compress key by removing y_axe and replace it with a prefix to x_axe key
    if q[1] % 2 == 0: # if y_axe (q[1]) is EVEN, append ‘\x02’ to ‘x_axe (q[0])'
        public_key_bytes = (b'\x02') + public_key_bytes
    else:
        public_key_bytes = (b'\x03') + public_key_bytes
    return public_key_bytes

'''Task set A: (calls tasks 12 to 15) phrase to private parent sequence''' 
# Old Task 11
def generate_lowest_parent_private_key(complete_phrase_binary_string, checksum_length, deriv_code):
    complete_phrase_binary_string = ''.join(complete_phrase_binary_string) #Join list in string
    complete_phrase_words = generate_complete_phrase(complete_phrase_binary_string)
    seed_bytes = generate_seed(complete_phrase_words)
    master_private_key_hex, master_chain_code_hex = generate_master_private_key(
    seed_bytes)
    lowest_parent_private_key_hex, lowest_parent_chain_code_hex = (
    find_lowest_private_parent_key(master_private_key_hex, master_chain_code_hex, 
    deriv_code))
    return lowest_parent_private_key_hex, lowest_parent_chain_code_hex, complete_phrase_words

'''Task set B: Generate a new child and search ‘user_bitcoin_addresses’ for a match ''' 
# Old 17
def test_new_address(lowest_parent_private_key_hex, lowest_parent_chain_code_hex, child_index_int):
    new_child_address = generate_public_child_addresses(lowest_parent_private_key_hex, lowest_parent_chain_code_hex, child_index_int)
    address_match = address_search(new_child_address)
    #print('address_match', address_match)
    if address_match == True:
        return new_child_address
    else:
        return None

''' Task set AAA: Checks checksum and if phrase is valid calls task sets A and B '''  
# Validates phrase, generates lowest_parent_private_key and then confirms if address is found 
# Ols task 10      
def abc(complete_phrase_binary_list, child_index_int):
    #complete_phrase_binary_string = incomplete_phrase_binary
    #print('complete_phrase_binary_list', complete_phrase_binary_list)
    complete_phrase_binary_string = ''.join(complete_phrase_binary_list) #Join list in string
    phrase_is_valid = validate_phrase(complete_phrase_binary_string, checksum_length)
    if phrase_is_valid: # 10% is True
        lowest_parent_private_key_hex, lowest_parent_chain_code_hex, complete_phrase_words = generate_lowest_parent_private_key(complete_phrase_binary_string, checksum_length, deriv_code)
        
        supersonic_magic_list.append([complete_phrase_words, lowest_parent_private_key_hex, lowest_parent_chain_code_hex])
        print(complete_phrase_words)
        matched_address = test_new_address(lowest_parent_private_key_hex, lowest_parent_chain_code_hex, child_index_int)    
        return matched_address, complete_phrase_words
    else:
        return None, None # If checksum of phrase is not valid, then ‘pass’ and next ‘nested_loop’ starts. 90% is false.
    

      
#### MAIN ####
# Task: Identify unknown word positions AND convert words to binary
validate_user_bitcoin_addresses()
incomplete_phrase_binary_list = words_to_binary()

''' Task set A: Loop: Insert binary number for missing words in phrase and call other 
functions. Calls task set B''' 
# Old task 9
# nested for loops. 
# insert binary number for missing words in word phrase
for child_index_int in range(child_index_start, child_index_end):
    if child_index_int == child_index_start:
        checksum_length = len(incomplete_phrase_binary_list)//3
    
        for number_x in range(2048):
            #print('number x:', number_x)
            # insert binary number for missing word 'x'
            incomplete_phrase_binary_list[unknown_word_positions[0]] = (format(number_x, 'b'
            ).zfill(11))   
            # we assume customer have max. 3 unknown words
            # loop inside loop used when unknown words are 2 or more
            if len(unknown_word_positions) > 1: # if there is a second missing word (y)
                for number_y in range(2048):
                    # insert binary number for missing word 'y'
                    incomplete_phrase_binary_list[unknown_word_positions[1]] = (format
                    (number_y, 'b').zfill(11))
                    # loop inside loop used when unknown words are 3 or more
                    if len(unknown_word_positions) > 2: # if there is a 3rd missing word then
                        for number_z in range(2048):
                            incomplete_phrase_binary_list[unknown_word_positions[2]] = (
                            format(number_z, 'b').zfill(11))
                            if len(unknown_word_positions) > 3: # if there is a 3rd missing word then
                                for number_p in range(2048):
                                    incomplete_phrase_binary_list[unknown_word_positions[3]] = (
                                    format(number_p, 'b').zfill(11))
                                    if len(unknown_word_positions) > 3: # if there is a 3rd missing word then
                                        for number_q in range(2048):
                                            incomplete_phrase_binary_list[unknown_word_positions[4]] = (
                                            format(number_q, 'b').zfill(11))
                                            matched_address, complete_phrase_words = abc(incomplete_phrase_binary_list, 
                                            child_index_int) 
                                            if matched_address != None:
                                                break                    
                                    else:
                                        matched_address, complete_phrase_words = abc(incomplete_phrase_binary_list, child_index_int)
                                    if matched_address != None:
                                        break
                                    # matched_address, complete_phrase_words = abc(incomplete_phrase_binary_list, 
                                    # child_index_int) 
                                    # if matched_address != None:
                                    #     break                    
                            else:
                                matched_address, complete_phrase_words = abc(incomplete_phrase_binary_list, child_index_int)
                            if matched_address != None:
                                break  
                            # matched_address, complete_phrase_words = abc(incomplete_phrase_binary_list, 
                            # child_index_int) 
                            # if matched_address != None:
                            #     break                    
                    else:
                        matched_address, complete_phrase_words = abc(incomplete_phrase_binary_list, child_index_int)
                    if matched_address != None:
                        break   
            else:
                matched_address, complete_phrase_words = abc(incomplete_phrase_binary_list, child_index_int)
            if matched_address != None:
                break
        if matched_address != None:
            break
    # If child_index_int is higher than 0, we do no longer require to generate the 
    # lowest_private_parent_key and chaincode and optimize / reduce processing by skipping
    # find_lowest_private_parent_key and tasks inside that step
    else:
        for list_item in supersonic_magic_list:
            matched_address = test_new_address(list_item[1], list_item[2], child_index_int)
            print("no1 "+ matched_address)
            if matched_address != None:      
                complete_phrase_words = list_item[0]
                print('matched_address', matched_address)
                break
        if matched_address != None:
            break
        
print('object size:', sys.getsizeof(supersonic_magic_list))
print(len(supersonic_magic_list))
''' Task 22: Report user after program completed. ''' 
if matched_address != None:
    print(f'Your 12 word phrase recovery has been successful. We’ve matched your public key: {matched_address}')
    print(f'Your correct 12 word prase is: {complete_phrase_words}')
else:
    print(f'Recovery not succesful. If you wish, you can contact our support.')
    print(f'You have searched child index: {child_index_start} till: {child_index_end}')

